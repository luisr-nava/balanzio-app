// Devoluciones de ventas (clientes devuelven productos)
model SaleReturn {
  id          String   @id @default(uuid())
  saleId      String?  // Opcional, puede ser una devolución sin venta específica
  sale        Sale?    @relation("SaleToReturn", fields: [saleId], references: [id])
  shopId      String
  totalAmount Float
  reason      String
  returnDate  DateTime @default(now())
  status      SaleReturnStatus @default(PENDING)

  // Qué se hizo con el dinero
  refundType  RefundType @default(CASH) // CASH, CREDIT, EXCHANGE
  refundAmount Float // Monto efectivamente devuelto

  notes       String?

  shop        Shop              @relation(fields: [shopId], references: [id])
  items       SaleReturnItem[]
  purchaseReturns PurchaseReturn[] // Devoluciones al proveedor generadas
}

model SaleReturnItem {
  id            String      @id @default(uuid())
  saleReturnId  String
  shopProductId String
  quantity      Int
  unitPrice     Float
  subtotal      Float
  reason        String? // Razón específica del producto
  condition     String? // Estado del producto (DEFECTIVE, EXPIRED, etc)

  saleReturn    SaleReturn  @relation(fields: [saleReturnId], references: [id], onDelete: Cascade)
  shopProduct   ShopProduct @relation(fields: [shopProductId], references: [id])
}

// Devoluciones a proveedores
model PurchaseReturn {
  id               String   @id @default(uuid())
  purchaseId       String?  // Compra original (opcional)
  supplierId       String
  shopId           String
  saleReturnId     String?  // Si viene de una devolución de venta
  totalAmount      Float
  returnDate       DateTime @default(now())
  status           PurchaseReturnStatus @default(PENDING)

  // Tipo de resolución
  resolutionType   ResolutionType @default(CREDIT_NOTE) // CREDIT_NOTE, REPLACEMENT, REFUND

  reason           String
  notes            String?

  supplier         Supplier        @relation(fields: [supplierId], references: [id])
  shop             Shop            @relation(fields: [shopId], references: [id])
  saleReturn       SaleReturn?     @relation(fields: [saleReturnId], references: [id])
  items            PurchaseReturnItem[]
  creditNote       CreditNote?     // Si se generó nota de crédito
  replacement      MerchandiseReplacement? // Si se generó reposición
}

model PurchaseReturnItem {
  id               String         @id @default(uuid())
  purchaseReturnId String
  shopProductId    String
  quantity         Int
  unitCost         Float
  subtotal         Float
  reason           String?

  purchaseReturn   PurchaseReturn @relation(fields: [purchaseReturnId], references: [id], onDelete: Cascade)
  shopProduct      ShopProduct    @relation(fields: [shopProductId], references: [id])
}

// Notas de crédito de proveedores
model CreditNote {
  id                String   @id @default(uuid())
  purchaseReturnId  String   @unique
  supplierId        String
  shopId            String
  amount            Float
  remainingAmount   Float    // Monto disponible
  issueDate         DateTime @default(now())
  expiryDate        DateTime? // Fecha de vencimiento (opcional)
  status            CreditNoteStatus @default(ACTIVE)
  notes             String?

  purchaseReturn    PurchaseReturn @relation(fields: [purchaseReturnId], references: [id])
  supplier          Supplier       @relation(fields: [supplierId], references: [id])
  shop              Shop           @relation(fields: [shopId], references: [id])
  applications      CreditNoteApplication[] // Usos de la nota de crédito
}

model CreditNoteApplication {
  id            String   @id @default(uuid())
  creditNoteId  String
  purchaseId    String
  amountApplied Float
  applicationDate DateTime @default(now())
  notes         String?

  creditNote    CreditNote @relation(fields: [creditNoteId], references: [id])
  purchase      Purchase   @relation(fields: [purchaseId], references: [id])
}

// Reposiciones de mercadería
model MerchandiseReplacement {
  id                String   @id @default(uuid())
  purchaseReturnId  String   @unique
  supplierId        String
  shopId            String
  status            ReplacementStatus @default(PENDING)
  requestDate       DateTime @default(now())
  deliveryDate      DateTime?
  notes             String?

  purchaseReturn    PurchaseReturn @relation(fields: [purchaseReturnId], references: [id])
  supplier          Supplier       @relation(fields: [supplierId], references: [id])
  shop              Shop           @relation(fields: [shopId], references: [id])
  items             ReplacementItem[]
}

model ReplacementItem {
  id                      String                @id @default(uuid())
  merchandiseReplacementId String
  shopProductId           String
  requestedQuantity       Int
  deliveredQuantity       Int                   @default(0)

  replacement             MerchandiseReplacement @relation(fields: [merchandiseReplacementId], references: [id], onDelete: Cascade)
  shopProduct             ShopProduct            @relation(fields: [shopProductId], references: [id])
}

// Enums
enum SaleReturnStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSED
}

enum PurchaseReturnStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSED
}

enum RefundType {
  CASH        // Devolución en efectivo
  CREDIT      // Crédito en tienda
  EXCHANGE    // Cambio de producto
}

enum ResolutionType {
  CREDIT_NOTE  // Nota de crédito
  REPLACEMENT  // Reposición de mercadería
  REFUND       // Devolución de dinero
}

enum CreditNoteStatus {
  ACTIVE
  PARTIALLY_USED
  FULLY_USED
  EXPIRED
  CANCELLED
}

enum ReplacementStatus {
  PENDING
  IN_TRANSIT
  DELIVERED
  CANCELLED
}
